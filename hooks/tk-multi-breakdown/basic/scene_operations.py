import os

import sgtk

HookClass = sgtk.get_hook_baseclass()


class SceneOperation(HookClass):
    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.
        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:
        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        engine = self.parent.engine
        operations = engine.operations

        references = operations.get_references()

        return references

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.
        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.
        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        engine = self.parent.engine
        operations = engine.operations
        framework_aliastranslations = None
        tk_framework_aliastranslations = None

        engine.logger.debug("Updating scene {}".format(items))

        for i in range(len(items)):
            _, ext = os.path.splitext(items[i]["path"])

            # create the wref file
            if ".wref" not in ext:
                source_path = items[i]["path"]
                output_path = operations.get_import_as_reference_output_path(
                    source_path
                )

                # if the output path doesn't exist, create it using the alias-translations framework
                if not os.path.exists(output_path):
                    if not framework_aliastranslations:
                        framework_aliastranslations = self.load_framework(
                            "tk-framework-aliastranslations_v0.x.x"
                        )

                    if not framework_aliastranslations:
                        raise Exception("Could not run alias translations")

                    if not tk_framework_aliastranslations:
                        tk_framework_aliastranslations = (
                            framework_aliastranslations.import_module(
                                "tk_framework_aliastranslations"
                            )
                        )

                    alias_translator = tk_framework_aliastranslations.Translator(
                        source_path, output_path
                    )
                    alias_translator.execute()
                else:
                    self.logger.info("The file {} already exists".format(output_path))

                items[i]["path"] = output_path

        operations.update_scene(items)
