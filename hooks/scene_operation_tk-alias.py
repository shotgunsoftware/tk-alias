import os

import sgtk
from sgtk.platform.qt import QtGui

from commands import SceneBreakdownCommand, UpdateSceneCommand

HookClass = sgtk.get_hook_baseclass()


class SceneOperation(HookClass):
    def execute(self, operation, file_path, context=None, parent_action=None, file_version=None, read_only=None,
                **kwargs):

        if operation == "current_path":
            return self.parent.engine.get_current_file()
        elif operation == "open":
            self.parent.engine.load_file(file_path, lambda: None)
        elif operation == "save":
            if file_path:
                self.parent.engine.save_file(file_path, parent=self.parent.instance_name)
            else:
                current_path = self.parent.engine.get_current_file()
                if current_path:
                    self.parent.engine.save_file(current_path, parent=self.parent.instance_name)
        elif operation == "save_as":
            self.parent.engine.save_file(file_path, parent=self.parent.instance_name)
        elif operation == "reset":
            self.parent.engine.current_file = None
            current_file = self.parent.engine.get_current_file()

            if current_file is not None:
                self.parent.engine.current_file = current_file

            if parent_action == "open_file":
                return True

            self.parent.engine.reset_scene(current_file=current_file)
            return True

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.
        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:
        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        app = self.parent.engine
        message = app.send_and_wait(message=SceneBreakdownCommand(), command= "RefFileList")

        if message:
            for msg in message["refs"]:
                msg['path'] = msg['path'].replace("/", os.path.sep)

            return message["refs"]
        return []

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.
        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.
        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        engine = self.parent.engine
        engine.log_info("update scene")
        engine.log_info(items)
        for msg in items:
            msg['path'] = msg['path'].replace("/", os.path.sep)
        refs_to_return = UpdateSceneCommand(items)
        command_result = engine.send_and_wait(refs_to_return)

        if command_result and command_result.has_key("initialCommand") and (command_result["initialCommand"] == refs_to_return.command):
            if command_result.has_key("status"):
                if command_result["status"] != "ok":
                    warning = "One or more selected file can not be updated./nIf there is another version of this file referenced, please check the Alias Reference Manager and remove its reference to enable the update."

                    if command_result.has_key("data"):
                        # We have a list of paths we can inform the user about
                        paths = command_result["data"]
                        warning += "/nFiles:/n" + "/n".join(paths)

                    QtGui.QMessageBox.warning(None, "Update Reference", warning)
